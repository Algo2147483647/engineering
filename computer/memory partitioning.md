# Memory Partitioning

[TOC]

## Context

生命周期管理：如何高效控制数据的“生与死”？数据在内存中存活的时间不同：函数局部变量只在函数执行期间存在。动态创建的数据（如对象、大数组）可能跨越多个函数调用，甚至存在于整个程序运行期。全局/静态数据需要在整个程序运行期间存在。程序代码本身是永久存在的。

作用域与访问控制：谁能访问数据，在哪里访问？不同数据需要不同的可见性和访问权限：函数局部变量只应在该函数内部访问。动态分配的数据可能需要被多个函数或模块访问（通过指针/引用传递）。全局数据需要被多个模块访问。程序代码应防止被意外或恶意修改。

内存分配效率与灵活性：如何快速获取所需空间？函数调用极其频繁，局部变量分配/释放必须**极快**。 程序运行中需要动态创建大小未知或变化的数据结构（如链表、树、用户输入数据）。需要支持大块内存的分配。

资源限制与碎片化：如何避免浪费和耗尽？ 无限递归或超大局部变量可能导致**栈溢出 (Stack Overflow)**，破坏程序。频繁的动态分配/释放不同大小的内存块会导致**内存碎片（外部碎片：空闲内存分散不连续；内部碎片：分配块大于实际需求）**，降低内存利用率，甚至导致分配失败（即使总空闲足够）。需要防止单个程序耗尽系统内存。

安全性与稳定性：如何防止错误和攻击？防止程序意外覆盖自身指令或关键数据。防止缓冲区溢出攻击（如覆盖栈上的返回地址）。 防止非法访问已释放内存（悬空指针）或未初始化内存。确保核心代码的完整性。

## Problem

生命周期管理需求不同： 不同数据需要存在的时间长短不同。

作用域和访问权限不同： 谁可以访问数据，在哪里访问数据。

大小和灵活性要求不同： 数据大小是编译时确定还是运行时动态变化。

性能和效率考量： 分配和释放内存的速度、内存碎片控制。

安全性和稳定性要求： 防止非法访问、保证系统核心功能不被破坏。

## Resolution

满足程序运行的不同需求，并实现效率、安全性、灵活性和可管理性的最佳平衡。

堆（Heap）、栈（Stack）、代码区（Code/Text Segment）





栈 (Stack)：目的： 管理函数调用和局部变量。

堆 (Heap)：存储动态分配的内存，这些内存在编译时无法确定大小或生命周期。

代码区 (Code Segment / Text Segment)：存储程序执行代码（编译后的机器指令）。

Data Segment: 